import React from 'react';
import { logWarning } from './propUtils';

class Container extends React.Component {
  // This is the component that my container is going to render
  setComponent(component, options = {}) {
    this.childComponent = component;
    this.options = options;
    let propTypes = component.propTypes || options.propTypes;

    // when you inject dinamically a different child component using props and
    // you want to add propTypes that are not set at design time in the child component
    if (options.props && options.props._component && typeof options.props._component.propTypes) {
      propTypes = Object.assign({}, propTypes,  options.props._component.propTypes)
    }

    if (typeof process !== "undefined" && process.env.NODE_ENV !== 'production') {
      if (!propTypes) {
        logWarning(`You are rendering ${component.name|| 'a component'} that has no propTypes. PropTypes are used by the Container
        to set the props the container will pass to the child component. If ${component.name|| 'your component'} doesn't use any props then ignore this warning`);
      }
    }

    // options.addProps are props that you want to explicitly inject to the container's child component.
    // This is not needed if you name the methods or the this.state keys that you want to pass down with the same name as the child component's propTypes.
    // options.addProps is not needed for properties that are injected already in the container, for instance
    // by other functions like react-redux connect function. In most cases you don't have to use options.addProps
    const addProps = options.addProps || {};

    let src = 'return {';
    for (let key in propTypes) {
      const addProp = addProps[key];
      if (addProp && typeof addProp === 'string') {
          src += `${key}: ${addProp},`;
      } else if (addProp) {
        logWarning(`{ addProps: {${key}} must be a string, example: 'this.state.user.id'`);
      } else {
        src += `${key}: this['${key}'] || props['${key}'] || (this.state && this.state['${key}']),`;
      }
    }

    if (propTypes) {
        src = src.slice(0,-1)
    }
    src += '}';
    this.getChildProps = Function('props', src);

    if (options.props && options.props._methods) {
      for (let key in options.props._methods) {
        const injectMethod = options.props._methods[key]
        if (this.hasOwnProperty(key) &&
          typeof this[key] === 'function' &&
          typeof injectMethod === 'function'
        ) {
          this[key] = injectMethod;
        }
      }
    }
  }

  render() {
    // The component that will be rendered can be set in two different ways:
    // 1. Via Container's props, example <ChatContainer component="MockChat" />.
    //    It'll be available in the Container as this.props._component
    // 2. Via constructor of the component that extends this Container.
    //    It'll be available as this.childComponent
    // this.props is checked first to enable dependency injection
    const ChildComponent = this.props._component || this.childComponent;
    const children = this.options.disablePropsChildren ? null : this.props.children;
    return (
      <ChildComponent {...this.getChildProps(this.props)} children={children}/>
    );
  }
}

export default Container;
